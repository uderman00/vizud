<!-- Contents/portfolio.html -->

<h1 id="top">My Portfolio</h1>
<!-- Card 0 – Airlines Routes -->

<p class="intro">
  Welcome! Here you’ll find a curated selection of projects that showcase my range as a data professional—
  from interactive D3.js visualisations to enterprise‑grade Power BI dashboards and deep‑dive DAX
  optimisation cases. Choose a track below or simply scroll to explore.
</p>

<nav class="portfolio-nav">
  <a href="#viz">Interactive Data Visualization </a>
  <a href="#bi">Business Intelligence Dashboards</a>
  <a href="#dax">DAX Performance & Optimization</a>
</nav>

<h2 id="viz"  class="section-title">Interactive Data Visualization</h2>
<section class="card">
  <h3> Airline Routes </h3>
  <p>
    This interactive project was developed as the final assignment for the course 
    <strong>"Information Visualization – Programming with D3.js"</strong>, offered by New York University.
    It visualizes global airline routes using D3.js and SVG-based geographic projections.
  </p>
  <p>
    As one of my first experiences with web development, this project was instrumental in expanding my understanding 
    of how to represent complex datasets through dynamic, browser-based visualizations. It combines data-driven design 
    with foundational front-end techniques (HTML, CSS, JavaScript) and focuses on clarity, interactivity, and scalability.
  </p>
  <iframe src="../Projects/d3-airlines/index.html" 
          width="1000" 
          height="600px" 
          style="border: 1px solid #ccc; border-radius: 8px;"></iframe>
</section>

<p class="backtop"><a href="#top">Back to top ↑</a></p>

<h2 id="bi"   class="section-title">Business Intelligence Dashboards</h2>

<!-- PROJECT: Executive Overview – Contoso -->
<section class="card project-card">
  <h3>Executive Overview – Contoso Sales Dashboard</h3>

  <!-- Dashboard image -->
  <img
    src="Projects/contoso-sales-2M/Executive Overview.png"
    alt="Executive Overview dashboard featuring a combo bar‑line chart of Revenue vs Target, a product‑category revenue funnel, horizontal bar charts for store revenue, a sales‑channel pie chart, and a revenue‑by‑country choropleth map."
    loading="lazy"
    style="width:100%; height:auto;"
  />

  <!-- Project description -->
  <p>
    This dashboard delivers a high‑level performance snapshot for Contoso’s leadership team.
    <strong>Key elements:</strong>
    <ul>
      <li><em>Revenue vs Target:</em> a combined bar + line chart tracking monthly revenue against goal.</li>
      <li><em>Product Structure Funnel:</em> highlights how revenue cascades through product categories.</li>
      <li><em>Store Revenue:</em> two horizontal bar visuals separate brick‑and‑mortar stores from other sales channels.</li>
      <li><em>Sales Channel Share:</em> a pie chart showing each channel’s percentage contribution.</li>
      <li><em>Revenue Heat Map:</em> a choropleth map that pinpoints the top‑performing countries.</li>
    </ul>
    Built on a star schema and optimized DAX, the report supports full interactivity:
    slicers for date and geography, drill‑through to store‑level detail, and rich tooltips with margin and volume metrics.
    It demonstrates best practices for storytelling and performance with a data set exceeding two million rows.
  </p>
</section>

<p class="backtop"><a href="#top">Back to top ↑</a></p>

<h2 id="dax"  class="section-title">DAX Performance &amp; Optimization</h2>
<!-- PROJECT: DAX Deep‑Dive – Nested Iterators vs Summarize -->
<section class="card project-card">
  <h3>Reducing Nested Iterators in DAX – A Hands‑On Example</h3>

  <p>
  Many real‑world DAX slow‑downs stem from iterators that traverse multiple related tables row by row.
  This case study begins with a naïve double <code>SUMX</code>—iterating first over
  <code>Store</code>, then over <code>Customer</code>—and shows how refactoring to a single
  <code>SUMMARIZE</code> on the <code>Sales</code> fact table removes relationship overhead,
  eliminates callback caches, and halves execution time.
  </p>


  <!-- Code comparison -->
  <h4>Original query (non‑optimized)</h4>
  <pre class="code-box"><code>
<span class="func">EVALUATE</span>
{
    <span class="func">SUMX</span>(                      <span class="comment">-- Outer iterator</span>
        Store,
        <span class="func">SUMX</span>(                  <span class="comment">-- Inner iterator</span>
            Customer,
            [Sales Amount]           <span class="comment">-- callback to FE</span>
        )
    )
}</code></pre>

  <h4>Optimized query</h4>
  <pre class="code-box"><code>
<span class="func">EVALUATE</span>
{
    <span class="func">SUMX</span>(
        <span class="func">SUMMARIZE</span>(             <span class="comment">-- single table</span>
            Sales,
            Sales[CustomerKey],
            Sales[StoreKey]
        ),
        [Sales Amount]             <span class="comment">-- computed in SE</span>
    )
}</code></pre>

<!-- Performance delta -->
<table class="perf-table">
  <thead>
    <tr>
      <th>Metric</th>
      <th>Original</th>
      <th>Optimized</th>
      <th>Δ&nbsp;(Δ%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Total time</td>
      <td>45.265ms</td>
      <td>22.087ms</td>
      <td class="improved">↓ 51 %</td>
    </tr>
    <tr>
      <td>Formula Engine&nbsp;(FE)</td>
      <td>19.841ms</td>
      <td>3.760ms</td>
      <td class="improved">↓ 81 %</td>
    </tr>
    <tr>
      <td>Storage Engine&nbsp;(SE)</td>
      <td>25.424ms</td>
      <td>18.327ms</td>
      <td class="improved">↓ 28 %</td>
    </tr>
    <tr>
      <td>SE&nbsp;CPU</td>
      <td>129.906ms</td>
      <td>57.578ms</td>
      <td class="improved">↓ 56 %</td>
    </tr>
    <tr>
      <td>SE&nbsp;Parallelism</td>
      <td>× 5.1</td>
      <td>× 3.1</td>
      <td class="worse">↓ 39 %</td>
    </tr>
  </tbody>
</table>


  <!-- Narrative -->
  <p>
    The first version relies on a <strong>double iterator</strong>
    (<code>SUMX(Store, SUMX(Customer…))</code>). That forces the Formula Engine (FE)
    to loop over <em>every possible combination</em> of stores and customers,
    triggering costly <em>callback data caches</em> to pull partial results from the
    Storage Engine (SE). Relationships between <code>Sales</code>,
    <code>Store</code> and <code>Customer</code> must also be materialized, adding extra overhead.
  </p>
  <p>
    By rewriting the query with
    <code>SUMMARIZE(Sales, Sales[CustomerKey], Sales[StoreKey])</code> we:
  </p>
  <ul>
    <li>Iterate only on <em>existing</em> <code>Store × Customer</code> pairs – no wasted loops.</li>
    <li>Stay entirely inside the <code>Sales</code> fact table, eliminating relationship navigation.</li>
    <li>Let the SE calculate <code>[Sales Amount]</code>, removing FE callbacks – the FE only performs the final aggregation.</li>
  </ul>
  <p>
    The result is a 50 % reduction in total execution time and an FE workload drop
    from 19.8 ms to 3.8 ms, proving how <strong>xmSQL inspection and query‑plan analysis</strong>
    translate into tangible performance gains.
  </p>
</section>

<p class="backtop"><a href="#top">Back to top ↑</a></p>